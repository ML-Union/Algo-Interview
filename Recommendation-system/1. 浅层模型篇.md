![](https://tva1.sinaimg.cn/large/008eGmZEly1gnso8ifglrj31c00qmmyj.jpg)


## 协同过滤

#### 请简述基于用户的协同过滤UserCF的推荐过程。

UserCF（User Collaboration Filter），即基于用户的协同过滤算法。其中协同过滤的含义是不同的用户通过与item的互动比如点赞、收藏等，使自己的推荐列表过滤掉自己不感兴趣的物品，从而得到最终的推荐结果。

以电商网站为例，他的步骤一般分为：

1）构成用户交互行为共现矩阵

假如用户对商品有浏览、收藏、加入购物车、购买这四种交互行为，我们分别给他们赋予分数 1分/3分/5分/10分，然后转化为共现矩阵，其中第一列表示用户，第一行表示商品，如下：


|  | 1 | 2 | 3| 4 | 5| 6 | 
| --- | --- | --- |--- |--- |--- |--- |
| A | 1 |  |5| 3 ||  |
| B |  | 3 ||  |3|  |
| C | 5 |  |3|  || 10 |
| D | 10 |  ||  |5|
| E |  | 10 |5| 1 || 


2）用户相似度计算

生成共现矩阵之后，问题就转为预测共现矩阵中空白位置的值。UserCF通过计算用户之间的相似度，找到用户相似度最高的topN个用户。

关于相似度计算，我们会在下一个问答中进行详细描述。

3）最终结果排序

得到相似度最高的N个用户之后，我们假定目标用户与其相似用户的喜好是相似的，可以根据其相似用户的已有评价对目标用户的偏好进行预测。往往通过加权平均的方式计算：

$$R_{u,p}=\frac{\sum_{s\in S}(w_{u,s}·R_{s,p})}{\sum_{s\in S}w_{u,s}}$$

其中$w_{u,s}$表示用户u和用户s的相似度，$R_{s,p}$表示用户s对物品p的评分。最终的推荐列表根据预测得分进行排序即可。

#### 在基于用户的协同过滤中，如何计算用户的相似度？

共现矩阵中的行向量表示用户向量，计算用户i和用户j的相似度问题，就是计算用户向量i和用户向量j之间的相似度，往往有以下几种方法：

- 余弦相似度

$$sim(i,j)=cos(i,j)=\frac{i·j}{||i||·||j||}$$

余弦相似度的缺陷是认为缺失值是0，但实际上并不总是如此。它衡量了用户向量i和用户向量j之间的向量夹角大小，夹角越小，余弦相似度越大，用户则越相似。

- 皮尔逊相关系数

$$sim(i,j)=\frac{\sum_{p\in P}(R_{i,p}-\bar {R_i})(R_{j,p}-\bar R_{j})}{\sqrt{\sum_{p\in P}(R_{i,p}-\bar {R_i})^2(R_{j,p}-\bar R_{j})^2}}$$

皮尔逊相似度使用用户平均分对评分进行修正，减小了用户评分偏置的影响。缺失值也是按用户平均分计算。其中$R_{i,p}$表示用户i对物品p的打分，$\bar {R_i}$表示用户i对所有物品的平均均分，p表示所有物品的集合。

也可引入物品相似度的方式对其改造，从而减少物品评分偏置对结果的影响。其中$\bar {R_p}$代表物品p得到所有评分的平均分。

$$sim(i,j)=\frac{\sum_{p\in P}(R_{i,p}-\bar {R_p})(R_{j,p}-\bar R_{p})}{\sqrt{\sum_{p\in P}(R_{i,p}-\bar {R_p})^2(R_{j,p}-\bar R_{p})^2}}$$

- Jaccard相似度

$$sim(A,B) = \frac{|r_A\cap r_B|}{|r_A\cup r_B|}$$

杰拉德相似度没有考虑评分大小，仅仅计算用户之间的交集和并集物品的大小。




#### 基于用户的协同过滤UserCF存在哪些缺陷？

1）在一个典型的互联网产品中，比如京东、淘宝、豆瓣、知乎，用户数往往远远大于物品的数量，而基于用户的协同过滤需要维护一个用户相似性矩阵，以便可以快速找出TopN相似用户。而维护该用户相似度矩阵所需的存储开销巨大，且随着业务发展，用户数的增长会导致用户相似度矩阵的空间复杂度以$n^2$的速度快速增长，会导致在线存储系统无法承载。

2）用户的行为矩阵往往是非常稀疏的，他点击过或者发生过行为的物品只占全量物品的很小一部分，而对于这样行为很稀疏的用户来说，通过相似度矩阵去寻找相似用户，准确度很低，存在很大的偶然性，并不能说明其确实存在相似性。对于那些反馈获取很少的产品来说，很难有好的推荐效果。


#### 请简述基于物品的协同过滤ItemCF的推荐过程。
ItemCF(Item Collaboration Filter)，即基于物品的协同过滤算法，它通过计算共现矩阵中物品列向量的相似度得到物品之间的相似度矩阵，再找到用户的历史正反馈物品的相似物品进行进一步排序和推荐。具体过程如下：

1）构成共现矩阵

|  | 1 | 2 | 3| 4 | 5| 6 | 
| --- | --- | --- |--- |--- |--- |--- |
| A | 1 |  |5| 3 ||  |
| B |  | 3 ||  |3|  |
| C | 5 |  |3|  || 10 |
| D | 10 |  ||  |5|
| E |  | 10 |5| 1 || 

2）物品相似度矩阵计算

计算共现矩阵两两列向量（物品向量）之间的相似度，构建物品相似度矩阵。

3）最终结果排序

针对用户历史正反馈物品列表，根据物品相似度矩阵，找出相似的TopN的物品，最终的物品排序计算逻辑如下：

$$R_{u,p}=\sum_{h\in H}(w_{p,h}·R_{u,h})$$
其中$H$为用户历史正反馈物品列表，$w_{p,h}$是物品$p$与物品$h$的相似度，$R_{u,h}$是用户$u$对物品$h$的已有评分。


#### UserCF和ItemCF分别适用于哪些应用场景？为什么？

1）UserCF基于用户相似度进行推荐，使其具备较强的社交属性，用户可以快速得知与自己兴趣相似的人最近喜欢的物品，即使某个兴趣点之前不在自己的兴趣范围内，也有可能通过“朋友”的动态快速更新自己的推荐列表。比如新闻推荐。

2）ItemCF适用于兴趣变化较为稳定的应用，即用户在一段时间内只对某一类物品感兴趣，这时根据物品相似度进行相似物品推荐比较合理，比如用户对电影的喜好。

#### 协同过滤算法存在哪些缺陷？

1）热门的物品具有很强的头部效应，容易跟大量物品产生相似性，即推荐结果的头部效应较明显；而尾部的物品由于特征稀疏，很少与其他物品产生相似性，导致很少被推荐，即处理稀疏向量的能力较弱。

2）协同过滤仅利用用户和物品的交互信息，无法有效地引入用户年龄、性别、商品描述、分类、时间地点等用户特征、物品特征和上下文特征。造成了有效信息的遗漏。

## 矩阵分解

#### 矩阵分解的原理是什么？求解的主要方法有哪些？

矩阵分解算法期望为每一个用户和物品生成一个隐向量，将用户和物品定位到隐向量的表示空间上，距离相近的用户和视频表明兴趣特点接近，推荐过程中把距离相近的视频推荐给目标用户。

具体地，用户和物品的隐向量是通过分解协同过滤生成的共现矩阵得到的，它将$m×n$维的共现矩阵$R$分解为$m×k$维的用户矩阵$U$和$k×n$的物品矩阵$V$相乘的形式。其中$m$是用户数量，$n$是物品数量，$k$是隐向量的维度，示意如下：


基于用户矩阵$U$和物品矩阵$V$，用户$u$对物品$i$的预估评分如下，其中$p_u$是用户$u$在用户矩阵$U$中的对应行向量，$q_i$是物品$i$在物品矩阵$V$中的对应列向量：

$$\hat { r_{ui} }=q_i^Tp_u$$

矩阵分解主要方法有特征值分解、奇异值分解和梯度下降。其中特征值分解只能用于方阵，不适用于分解用户-物品。奇异值分解在互联网场景下复杂度和适用性不足，梯度下降是常用的求解方法。

#### 如何从深度学习模型的角度来认识矩阵分解模型

矩阵分解层的用户隐向量和物品隐向量可以看做是一种Embedding方法，最终的Scoring层就是将用户隐向量和物品隐向量进行内积操作后得到“相似度”，这里的“相似度”就是对评分的预测。

实际使用矩阵分解训练和评估模型的过程中，因为矩阵分解的模型结构相对简单，而且输出层无法对优化目标进行有效的拟合，往往会发现模型容易处于欠拟合的状态。


#### 矩阵分解算法中，隐向量的长度$k$的取值是如何影响效果和工程开销的？

矩阵分解中，$k$表示的是隐向量的长度，$k$的大小决定了隐向量表达能力的强弱。$k$的取值越小，隐向量包含的信息越少，模型的泛化能力越高；反之，$k$的取值越大，隐向量的表达能力越强，但泛化能力相应降低。

此外，$k$的取值与矩阵分解的求解复杂程度直接相关，$k$的取值越大，求解复杂度就越大，反之就越小。实际应用中，$k$的取值要经过多次试验找到一个推荐效果和工程开销的平衡点。


#### 请简述奇异值分解的过程。奇异值分解存在什么缺陷？为什么不适用于互联网场景下的求解？
假设共现矩阵$M$是一个$m×n$的矩阵，则一定存在一个分解$M=U\sum V^T$，其中$U$是$m×m$的正交矩阵，$V$是$n×n$的正交矩阵，$\sum$是$m×n$的对角阵。

取对角阵$\sum$中较大的k个元素作为隐含特征，删除其他维度以及$U$和$V$中对应的维度，矩阵$M$被分解为$M≈U_{m×k}\sum_{k×k}V_{k×n}$，即完成矩阵分解。

但奇异值分解存在着两点缺陷，使之不适用于互联网场景下的矩阵分解求解：

1）奇异值分解要求原始的共现矩阵是稠密的。而互联网场景下大部分用户的行为历史非常少，用户-物品的共现矩阵非常稀疏，如果应用奇异值分解，就必须对缺失的元素值进行填充。

2）传统奇异值分解的计算复杂度达到了$O(mn^2)$的级别，这对于商品数量上千万、用户数量上百万的互联网场景是不可接受的。

#### 请简述梯度下降法求解用户-物品隐向量的过程。

根据预估评分$\hat { r_{ui} }=q_i^Tp_u$得到求解矩阵分解的目标函数，其目的是让原始评分$r_{ui}$与用户向量和物品向量之积$q_i^Tp_u$的差尽量小，这样才可以最大限度地保存共现矩阵的原始信息。

$$\min _{ q^*,p^*}{\sum _{(u,i)\in K}(r_{ui}-q_i^Tp_u)^2}$$

为减少过拟合，加入正则化项：

$$\min _{ q^*,p^*}{\sum _{(u,i)\in K}(r_{ui}-q_i^Tp_u)^2}+\lambda (||q_i||+||p_u||)^2$$

对$q_i$求偏导，得到：

$$2(r_{ui}-q_i^Tp_u)p_u-2\lambda q_i$$

对$p_u$求偏导，得到：

$$2(r_{ui}-q_i^Tp_u)q_i-2\lambda p_u$$

然后沿着梯度反向更新参数：

$$q_i \leftarrow q_i -\gamma ((r_{ui}-q_i^Tp_u)p_u-\lambda q_i)$$

$$p_u \leftarrow p_u -\gamma ((r_{ui}-q_i^Tp_u)q_i -\lambda p_u)$$

当迭代次数超过上限或损失函数值低于阈值时，结束训练。

#### 如何解决矩阵分解中用户和物品打分偏差的问题？

不同用户的打分体系不一样，不同物品的衡量标准也不同，为了消除用户和物品的打分偏差，可以再矩阵分解时加入用户和物品的偏差向量：

$$r_{ui}=\mu+b_i+b_u+q_i^Tp_u$$
其中$\mu$是全局偏差常数，$b_i$是物品偏差系数，可使用物品$i$收到的所有评分的均值，$b_u$是用户偏差系数，可使用用户$u$给出的所有评分的均值。加入用户和物品打分偏差项之后，矩阵分解得到的隐向量更能反映不同用户对不同物品的“真实”态度差异，避免推荐结果有偏。

此时，矩阵分解目标函数也发生相应改变：

$$\min _{ q^*,p^*,b^* }{\sum _{(u,i)\in K}(r_{ui}-\mu-b_u-b_i-p_u^Tq_i)^2+\lambda (||p_u||^2+||q_i||^2+b_u^2+b_i^2)  } $$

#### 矩阵分解有哪些优点与缺点？与协同过滤相比较呢？

1）泛化能力强。针对协同过滤算法的头部效应明显、泛化能力弱的问题，矩阵分解方法在“共现矩阵”的基础上，加入了隐向量的概念，使得任意的用户和物品之间都可以得到预测得分，加强了稀疏矩阵的能力。隐向量的生成过程其实是对共现矩阵进行全局拟合，利用全局信息生成的，有更强的泛化能力。

2）空间复杂度骤降。不需要存储协同过滤模型服务阶段所需的“庞大”的用户相似性或物品相似性矩阵，只需存储用户和物品隐向量。空间复杂度从$n^2$级别降低到$(m+n)·k$

3）更好的扩展性和灵活性。矩阵分解中得到的用户和物品隐向量，与深度学习中的embedding思想不谋而合，因此矩阵分解的结果也非常便于与其他特征进行组合和拼接，并便于与深度学习无缝结合。

对于协同过滤来说，若两个用户没有相同的历史行为或者两个物品没有相同的人购买，则用户之间或物品之间的相似度为0，这就使得协同过滤没有泛化能力。

但与协同过滤一样，矩阵分解同样不方便加入用户、物品和上下文相关特征，使得矩阵分解丧失了利用很多有效信息的机会，同时在缺乏用户历史行为时，无法有效的推荐。


#### 如何从神经网络的角度理解矩阵分解？


## 逻辑回归

#### 逻辑回归模型预估相较于协同过滤，最大的优势是什么？其推荐过程是怎么样的？

相比协同过滤模型仅利用用户与物品的相互行为信息进行推荐，逻辑回归模型能综合利用用户、物品、上下文等多种不同的特征，生成较为全面的推荐结果。

不同于协同过滤和矩阵分解利用用户和物品的“相似度”进行推荐，逻辑回归将推荐问题转换成一个的点击率预估问题，也即预测正样本的概率对物品进行排序，其具体推荐过程如下：

1）将用户特征、物品特征、上下文特征转化为数值型特征向量

2）确定逻辑回归模型的优化目标，利用已有样本数据对逻辑回归进行训练，确定逻辑回归模型的参数

3）在预测阶段，将特征向量输入逻辑回归模型，得到用户点击物品的概率（CTR）

4）利用CTR对所有候选物品进行排序，得到推荐列表


#### 请推导逻辑回归的数学形式。

1）模型输入为特征向量$x=(x_1,x_2,···,x_n)$

2）特征向量的权重向量为$W=(w_1,w_2,···w_{n+1})$，将各特征加权求和，得到$w^Tx$

3）将特征加权和$w^Tx$输入sigmoid $f(z)=\frac{1}{1+e^{-z}}$函数，使之映射到0~1的区间，得到点击率。

所以最终的数学形式如下：

$$f(x) = \frac{1}{1+e^{-(w^Tx+b) }}$$


#### 请推导梯度下降法求解逻辑回归参数更新的过程。

一个样本可以理解为发生的一次事件，样本生成的过程即事件发生的过程。对于0/1分类问题来讲，产生的结果有两种可能，符合伯努利试验的概率假设。因此，我们可以说样本的生成过程即为伯努利试验过程，产生的结果（0/1）服从伯努利分布。这里我们假设结果为1的概率为$h_\theta{(x)}$，结果为0的概率为$1-h_\theta{(x)}$。

那么对于第$i$个样本，概率公式表示如下：
$$P(y^{(i)}=1|x^{(i)};\theta )=h_\theta{(x^{(i)})}$$$$P(y^{(i)}=0  |x^{(i)};\theta )=1- h_\theta{(x^{(i)})}$$
将上面两个公式合并在一起，可得到第$i$个样本正确预测的概率：
$$P(y^{(i)}|x^{(i)};\theta)=(h_\theta(x^{(i)})^{y(i)})·（1-h_\theta(x^{(i)}))^{1-y(i)}$$
上式是对一个样本进行建模的数据表达。对于所有的样本，假设每条样本生成过程独立，在整个样本空间中（N个样本）的概率分布（即似然函数）为：
$$
P\left(Y|X;\theta\right)=\prod_{i=1}^N{\left(h_{\theta}\left(x^{\left(i\right)}\right)^{y^{\left(i\right)}}\left(1-h_{\theta}\left(x^{\left(i\right)}\right)^{1-y^{\left(i\right)}}\right)\right)}
$$


如果从统计学的角度可以理解为参数$\theta$似然性的函数表达式（即似然函数表达式）,就是利用已知的样本分布，找到最有可能（即最大概率）导致这种分布的参数值；或者说什么样的参数才能使我们观测到目前这组数据的概率最大。参数在整个样本空间的似然函数可表示为：
$$
L\left(\theta\right)=P\left(\overrightarrow{Y}|X;\theta\right)
$$
$$
=\prod_{i=1}^N{P\left(y^{\left(i\right)}\parallel x^{\left(i\right)};\theta\right)}
$$
$$
=\prod_{i=1}^N{\left(h_{\theta}\left(x^{\left(i\right)}\right)\right)^{y\left(i\right)}\left(1-h_{\theta}\left(x^{\left(i\right)}\right)\right)^{1-y^{\left(i\right)}}}
$$
为了方便参数求解，对这个公式取对数，可得对数似然函数：
$$
l\left(\theta\right)=\sum_{i=1}^N{\log l\left(\theta\right)}
$$
$$
=\sum_{i=1}^N{y^{\left(i\right)}\log\left(h_{\theta}\left(x^{\left(i\right)}\right)\right)+\left(1-y^{\left(i\right)}\right)\log\left(1-h_{\theta}\left(x^{\left(i\right)}\right)\right)}
$$
最大化对数似然函数其实就是最小化交叉熵误差（Cross Entropy Error）。
先不考虑累加和，我们针对每一个参数$w_j$求偏导：
$$
\frac{\partial}{\partial\theta_j}l\left(\theta\right)=\left(y\frac{1}{h_{\theta}\left(x\right)}-\left(1-y\right)\frac{1}{1-h_{\theta}\left(x\right)}\right)\frac{\partial}{\partial\theta_j}h_{\theta}\left(x\right)
$$
$$
=\left(\frac{y\left(1-h_{\theta}\left(x\right)\right)-\left(1-y\right)h_{\theta}\left(x\right)}{h_{\theta}\left(x\right)\left(1-h_{\theta}\left(x\right)\right)}\right)h_{\theta}\left(x\right)\left(1-h_{\theta}\left(x\right)\right)\frac{\partial}{\partial\theta_j}\theta^Tx
$$
$$
=\left(y-h_{\theta}\left(x\right)\right)x_j
$$
最后，通过扫描样本，迭代下述公式可求得参数：
$$
\theta_j:=\theta_j+a\left(y^{\left(i\right)}-h_{\theta}\left(x^{\left(i\right)}\right)\right)x_{j}^{\left(i\right)}
$$
其中$a$表示学习率，又称学习步长。此外还有Batch GD，共轭梯度，拟牛顿法（LBFGS），ADMM分布学习算法等都可以用来求解参数。

#### 逻辑回归作为CTR预估模型的优势与缺陷是什么？

优势：

1）数学含义相符：逻辑回归的假设是因变量$y$服从伯努利分布，也即0-1分布，在点击率预估问题中，用户是否点击物品符合伯努利分布，也即可以说训练样本的生成过程即为伯努利试验过程，产生的结果（0/1，是否点击）服从伯努利分布

2）可解释性强：逻辑回归的数学形式是各特征加权和，再施以sigmoid函数，其中权重代表特征的重要性，通过sigmoid函数映射到0~1，刚好符合CTR的物理意义。工程师可轻易根据权重来确定特征的重要性排序，与产品运营沟通时，也便于给出解释的原因。

3）易于工程化：逻辑回归易于并行化、模型简单、训练开销小，这些特点使得其在工程上易于维护和实现，即使其他复杂模型的效果有所提升，再没有明显击败逻辑回归模型之前，公司也不会贸然加大计算资源的投入。

缺陷：

1）表达能力不强，无法进行特征交叉、特征选择等操作，造成信息的损失。
## FM与FFM

#### 所有的特征进行两两交叉，并对所有的的组合赋予权重的方法存在什么缺陷？

1）处理互联网数据时，经常采用one-hot编码方法处理类别型数据，使得特征向量很稀疏，若对所有特征进行两两交叉，原本就很稀疏的特征向量更加稀疏，导致大部分交叉特征缺乏有效的数据进行训练，无法收敛。

2）权重参数的数量从n直接上升到$n^2$，极大地增加了训练复杂度。


#### FM的原理是什么？与矩阵分解有什么联系？

FM为每个特征学习了一个隐权重向量，在特征交叉时，使用特征隐向量的内积作为交叉特征的的权重。

$$FM(w,x)=\sum_{j_1=1}^n\sum_{j_2=j_1+1}^n(w_{j_1}·w_{j_2})x_{j_1}x_{j_2}$$

本质上，FM引入隐向量的做法，与矩阵分解用隐向量代表用户和物品的做法异曲同工。FM是对矩阵分解隐向量的思想做了进一步分扩展，从单纯的用户、物品隐向量扩展到了所有特征上。





#### FM相较于POLY2为什么泛化能力更好？在工程上有什么优势？

在某商品推荐的场景下，样本有两个特征，分别是频道和品牌，某条训练样本的特征组合是(ESPN，Adidas)。在POLY2算法中，只有当ESPN和Adidas同时出现在同一个训练样本中，模型才能学到这个组合特征对应的权重；

而在FM中，ESPN的隐向量也可以通过（ESPN,Gucci）样本进行更新，Adidas的隐向量也可以通过（NBC,Adidas）进行更新，大幅降低了模型对于数据稀疏性的要求，甚至对于一个从来没有出现过的特征组合（NBC,Gucci），由于模型之间已经分别学习过NBC和Gucci的隐向量，具备了计算该特征组合权重的能力，但是泛化能力大大提高。

在工程上，FM同样可以用梯度下降法进行学习，使其不失实时性和灵活性。相比之后深度学习模型复杂的网络结构导致难以部署和线上服务，FM较容易实现的模型结构使其线上推断的过程相对简单，也更容易进行线上部署和服务。



#### FFM相较于FM有什么改进？

相比FM模型，FFM模型引入了特征域的概念，其数学形式的二阶部分如下：

$$FM(w,x)=\sum_{j_1=1}^n\sum_{j_2=j_1+1}^n(w_{j_1f_2}·w_{j_2f_1})x_{j_1}x_{j_2}$$

其与FM的区别在于隐向量由原来的$w_{j_1}$变成了$w_{j_1,f_2}$，这意味着每个特征对应的不是唯一一个隐向量，而是一组隐向量。当$x_{j_1}$特征与$x_{j_2}$特征进行交叉时，$x_{j_1}$会从$x_{j_1}$的这一组隐向量中挑出与特征$x_{j_2}$的域对应的隐向量$w_{j_1f_2}$进行交叉。同理，$x_{j_2}$也会用与$x_{j_1}$的域$f_1$对应的隐向量进行交叉。

其中的域指的是特征域，比如性别、品牌、广告分类就是三个不同的特征域。

#### FM的训练复杂度是多少？怎么推导？FFM的训练复杂度是多少？


## GBDT+LR

#### 为什么GBDT可用于特征选择和特征组合？

GBDT是由多颗回归树组成的树林，后一棵树以前面树林的结果与真实结果的残差为拟合目标。每棵树生成的过程是一课标准的回归树生成过程，因此回归树中每个节点的分裂是一个自然的特征选择过程，而多层节点的结构则对特征进行了有效的自动组合，也就非常高效地解决了特征选择和特征组合的问题。


#### GBDT+LR组合模型中，GBDT是如何生成特征向量的？

#### GBDT+LR有什么优点和缺陷？

在推荐系统领域，大大推进了特征工程模型化的趋势。之前特征工程的解决方法主要有两个：一个是进行人工的或半人工的特征组合和特征筛选，对算法工程师的经验和精力投入要求较高；二是通过改造目标函数，改进模型结构，增加特征交叉项的方式增强特征组合能力，要求从根本上改变模型结构，对模型设计能力的要求较高。

GBDT+LR的提出意味着特征工程可以完全交由一个独立的模型来完成，模型的输入可以是原始的特征向量，不必在特征工程上投入过多的人工筛选和模型设计的精力，真正实现了端到端的训练。

但GBDT无法进行完全并行的训练，更新所需的训练时长较长。
## LS-PLM

#### 请简述阿里妈妈提出的LS-PLM模型的原理与数学形式。

LS-PLM可以看作对逻辑回归的自然推广，在逻辑回归的基础上采用分而治之的思路，先对全量样本进行聚类分片，再对每个分类施以逻辑回归模型进行CTR预估。

其数学形式如下，首先用聚类函数$\pi$(softmax多分类)对样本进行分类,在用LR模型计算分片中具体的CTR,两者相乘：

$$f(x)=\sum_{i=1}^{m}\pi_i(x)\eta_i(x)=\sum_{i=1}^m\frac{e^{\mu_i·x}}{\sum_{j=1}^me^{\mu_j·x}}·\frac{1}{1+e^{-w_i·x}}$$

其中超参数即分片数$m$可以很好地平衡模型的拟合与推广能力，当$m=1$时，LS-PLM就退化为普通的逻辑回归。m越大，模型的拟合能力越强。与此同时，模型参数规模也会随着$m$的增大而线性增长，模型收敛所需的训练样本也随之增长。实践中，阿里巴巴给出的$m$的经验值为12。


#### LS-PLM模型的优势有哪些？

LS-PLM适用于推荐广告等大规模稀疏数据的场景，其优势在于：

1）端到端的非线性学习能力：LS-PLM具有样本分片的能力，因此能够挖掘出非线性模式，省去了大量的人工样本处理和特征工程的过程，可以端到端训练，便于用一个全局模型对不同应用领域、业务场景进行统一建模。

2）模型的稀疏性强：在建模时引入了L1和L2,1范数，可使得最终训练出来的模型局哟偶高度的稀疏度，使模型的部署更加轻量级。模型服务过程仅需使用权重非零特征，因此稀疏模型也使其在线推断效率更高。

#### LS-PLM模型与深度学习模型有什么联系？

LS-PLM可以看做是一个加入了注意力（Attention）机制的三层神经网络模型，其中输入层是样本的特征向量，中间层是由m个神经元组成的隐层，其中m是分片的个数，输出层为单一的神经元；在隐层与输出层之间，神经元之间的权重是由分片函数得出的注意力得分来确定的，即样本属于某个分片的概率就是其注意力得分。


